class Foo
{
	public Foo()
	{
		i = 3;
		j = 7;
	}

	public Foo(int in)
	{
		i = in;
		j = 7;
	}

	int64 j;
	int i;
}

// Implicit c'tor
class Bar
{
	uint i;
	float64 j;
}

// Explicit c'tor with args
class Baz
{
	public Baz(uint a, float b, char c)
	{
		i = a;
		j = b;
		k = c;
	}

	uint i;
	float j;
	char k;
	Foo& _foo1;
	Foo _foo2;
}

class FooBar
{
	public FooBar()
	{
		_foo = new Foo();
	}

	public fun(Foo retVal) GetFoo()
	{
		return _foo;
	}

	private Foo _foo;
}

class Program 
{
	static fun(int ret) main()
	{
		unsafe
		{
			// 0123456789
			int a[10];
			int counter = 0;
			while (counter < 10)
			{
				a[counter] = counter;
				counter++;
			}
			counter = 0;
			while (counter < 10)
			{
				print(a[counter]);
				counter++;
			}

			// aaaaa
			char c[5];
			counter = 0;
			while (counter < 5)
			{
				c[counter] = 'a'; // TODO When casting is supported: (char)(((int)'a')+counter);
				counter++;
			}
			counter = 0;
			while (counter < 5)
			{
				print(c[counter]);
				counter++;
			}

			// 3737373737
			Foo d[5];
			counter = 0;
			while (counter < 5)
			{
				d[counter] = new Foo();
				counter++;
			}
			counter = 0;
			while (counter < 5)
			{
				print(d[counter].i);
				print(d[counter].j);
				counter++;
			}

			// 00.5x3711.5x3722.5x3733.5x3744.5x37
			Baz& e[5];
			counter = 0;
			while (counter < 5)
			{
				Baz& f((uint)counter, (float)counter + 0.5, 'x');
				e[counter] = f;
				counter++;
			}
			counter = 0;
			while (counter < 5)
			{
				print(e[counter].i);
				print(e[counter].j);
				print(e[counter].k);
				print(e[counter]._foo1.i);
				print(e[counter]._foo1.j);
				counter++;
			}

			{
				Foo buffer[1];
				let foo1 = new Foo(1);
				buffer[0] = foo1;
				print(foo1.i); // 1
				buffer[0] = new Foo(2);
				print(foo1.i); // 1
				print(buffer[0].i); // 2
				buffer[0] = foo1;
				print(foo1.i); // 1
				foo1.i = 3;
				print(foo1.i); // 3
				buffer[0].i = 6;
				print(buffer[0].i); // 6
			}

			{
				Foo& buffer[1]; // uninitialized foos! That works since this is "unsafe" code... but we'll need a solution for the safe case. Default c'tor required, probably? Supply a c'tor to the array initialization?
				Foo& foo2(1);
				buffer[0] = foo2; // copy
			
				print(foo2.i); // 1
				print(buffer[0].i); // 1
				buffer[0].i = 4;
				foo2.i = 5;
				print(foo2.i); // 5
				print(buffer[0].i); // 4

			}

			FooBar foobar = new FooBar();
			print(foobar.GetFoo().i); // 3
			foobar.GetFoo().i = 9;
			print(foobar.GetFoo().i); // 9
		}

		let baz = new Baz(1,2.5,'a');
		// 12.5a3737
		print(baz.i);
		print(baz.j);
		print(baz.k);
		print(baz._foo1.i);
		print(baz._foo1.j);
		baz._foo2 = new Foo();
		print(baz._foo2.i);
		print(baz._foo2.j);
		// 12.5a3737
		let baz2 = baz;
		print(baz2.i);
		print(baz2.j);
		print(baz2.k);
		print(baz2._foo1.i);
		print(baz2._foo1.j);
		print(baz2._foo2.i);
		print(baz2._foo2.j);
		print("\r\n");
		// 10039.288b57593173
		baz = new Baz(100, 39.288,'b');
		baz._foo1.i = 57;
		baz._foo1.j = 59;
		baz._foo2 = new Foo();
		baz._foo2.i = 31;
		baz._foo2.j = 73;
		print(baz.i);
		print(baz.j);
		print(baz.k);
		print(baz._foo1.i);
		print(baz._foo1.j);
		print(baz._foo2.i);
		print(baz._foo2.j);
		print("\r\n");
		// 12.5a373737
		print(baz2.i);
		print(baz2.j);
		print(baz2.k);
		print(baz2._foo1.i);
		print(baz2._foo1.j);
		print(baz2._foo2.i);
		print(baz2._foo2.j);
		baz._foo2 = new Foo();
		print(baz._foo2.i);
		print(baz._foo2.j);
		print("\r\n");

		// 1317.25c3737
		Baz& baz3(13, 17.25, 'c');
		baz3._foo2 = baz._foo2;
		print(baz3.i);
		print(baz3.j);
		print(baz3.k);
		print(baz3._foo1.i);
		print(baz3._foo1.j);
		print(baz3._foo2.i);
		print(baz3._foo2.j);
		print("\r\n");

		// 1317.25c3737
		Baz& baz4 = baz3;
		print(baz4.i);
		print(baz4.j);
		print(baz4.k);
		print(baz4._foo1.i);
		print(baz4._foo1.j);
		print(baz4._foo2.i);
		print(baz4._foo2.j);

		//print(MathClass.Factorial(5));
		return 0;
	}
}